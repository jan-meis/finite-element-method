# finite-element-method
Github link: https://github.com/jan-meis/finite-element-method.git

# how to use
1) Download files and save them to a folder.
2) Open Matlab.
3) (Important!) Make sure the folder containing the 'main_...' files is selected as the current folder in Matlab. 
4) Run one of the 'main_...' files.

# general features
Methods for solving both the sine and the cosine problem are given.
The correct solution for both problems has been calculated analytically and is compared to the approximate solutions via:
1) Display of the maximum absolute error on all evaluation points (on a 101x101 Grid)
2) Display of the average absolute error over all evaluation points
3) Display of the quotient of  (L2 norm of the absolute error ) / (L2 norm of the absolute value (to avoid division by zero) of the reference solution)
These calculations are repeated for increasingly finer meshes and then displayed  for comparison.
An a posteriori error estimator (page 290 in Grossmann & Roos) is implemented and evaluated in each step.
Linear, bilinear and quadratic polynomials are implemented.
The linear system is solved with my own implementation of the CG method.
Meshes generated by the program Triangle can be loaded and used.
The program uses my own implementation of a polynomial class. Most calculations at some point fall back to evaluating polynomials represented by this class.
This leads to derivatives of all polynomials being exact. (Exact integration of polynomials has also been implemented for 'well oriented' squares, but there are no examples of this in use in the main_... files.)
There are 10 working examples provided, each one displaying a different combination of the aforementioned features. These examples are labeled 'main_...' and are described below.

# features of the different main_ files
main_square_bilinear_sinsin: This uses bilinear polynomials and solves sin(pi*x)*sin(pi*y) with dirichlet boundary conditions on a uniform mesh
main_triangle_linear_sinsin: This uses linear polynomials and solves sin(pi*x)*sin(pi*y) with dirichlet boundary conditions on a uniform mesh
main_square_bilinear_coscos: This uses bilinear polynomials and solves cos(pi*x)*cos(pi*y) with neumann boundary conditions on a uniform mesh
main_triangle_linear_coscos: This uses linear polynomials and solves cos(pi*x)*cos(pi*y) with neumann boundary conditions on a uniform mesh
main_triangle_quad_sinsin: This uses quadratic polynomials and solves sin(pi*x)*sin(pi*y) with dirichlet boundary conditions on a uniform mesh
main_triangle_quad_coscos: This uses quadratic polynomials and solves cos(pi*x)*cos(pi*y) with neumann boundary conditions on a uniform mesh
main_custommesh_quad_sinsin: This uses quadratic polynomials and solves sin(pi*x)*sin(pi*y) with dirichlet boundary conditions on a custom mesh created by Triangle
main_custommesh2_quad_sinsin: This uses quadratic polynomials and solves sin(pi*x)*sin(pi*y) with dirichlet boundary conditions on a different custom mesh created by Triangle
main_custommesh_quad_coscos: This uses quadratic polynomials and solves cos(pi*x)*cos(pi*y) with neumann boundary conditions on a custom mesh created by Triangle
main_custommesh2_quad_coscos: This uses quadratic polynomials and solves cos(pi*x)*cos(pi*y) with neumann boundary conditions on a different custom mesh created by Triangle

# known limitations
The program runs very slow for 'very' fine meshes.
'Very' on my machine meant calculation for 100 cells took about 1.5 minutes.
This is largely because the evaluation of the solution on the 101x101 grid is very badly optimized.
While this is definately fixable for the 'uniform mesh case', i cannot think of an easy fix for a generic mesh created by the Triangle program.
Also note that the program does not abuse the fact that you theoretically only need to calculate most integrals for the matrix assembly once on a reference cell and then map that to all other cells. Instead, every integral on every cell is calculated independently.

# .poly, .node and .ele files
These files are created by the program Triangle (https://www.cs.cmu.edu/~quake/triangle.html) (Jonathan Richard Shewchuk)

# .mesh files
These kind of files are useful for trying out "selfmade" meshes, because they are easy to create by manually typing in numbers.
None of the main_ files currently uses them, but they can be useful if one might want to try out a silly mesh in the oral exam.
These files are structures in the following way:

<#number of vertices>
<#vertex index> <x> <y> <isBoundaryPoint>
<#vertex index> <x> <y> <isBoundaryPoint>
<#vertex index> <x> <y> <isBoundaryPoint>
<#vertex index> <x> <y> <isBoundaryPoint>
...
<#number of triangles>
<index of first triangle vertex> <index of second triangle vertex> <index of third triangle vertex>
<index of first triangle vertex> <index of second triangle vertex> <index of third triangle vertex>
<index of first triangle vertex> <index of second triangle vertex> <index of third triangle vertex>
<index of first triangle vertex> <index of second triangle vertex> <index of third triangle vertex>
<index of first triangle vertex> <index of second triangle vertex> <index of third triangle vertex>
...
Note that triangle indices have to go around the triangle in a counterclockwise manner!
